Verifier (Верификатор)
======================
Простая библиотека динамической проверки данных.

Особенности:
------------
* Произвольная структара проверяемых данных (можноиспользовать как ассоциативный массив так и объект являющийся моделью данных)
* Гибкое построение правил валидации, список стандартных методов проверки
* Валидацию производить можно как для одного поля так и списком (в этом случае списковое поле будет ошибочным, если хотябы один элемент списка не будет удовлетворять хотябы одному из правил валидации)
* В случае когда для проверки недостаточно стандартных методов можно воспользоваться проверкой посредством *callback* функцией или регулярным выражением

Использование:
--------------
Инициализация Верификатора осуществляется инстанцированием главного класса *Verifier*.

```php
<?php
require_once 'Path_to_lib/Verifier.php';
$verifier = new Verifier\Verifier($_REQUEST['some_form']);
```

###Поля для проверки инициализируются следующим образом:

```php
<?php
#------
$emailField = $verifier->field('email');
```

*email* - это путь к полю в контексте принятых данных, если путь касается не одной вложенности, то его следует указывать через точку. Например `user.email`

###Тем самым произведена инициализация проверки поля *email* данных запроса *some_form*, которое можно проверить стандартными методами проверки:

```php
<?php
#------
$emailField->notNull('`Email` field must not be empty')->ifValid()->email('`Email` field is invalid format');
```

Для инициализации спискового значения необходимо использовать метод *each*. В этом случае проверки для поля будут производится в каждом элементе списка.
У поля по цепочке можно вызывать методы проверки. Список всех методов будет рассмотрен далее. Так же иногда бывают бессмысленными выполнения одних проверок если проведенная ранее проверка потерпела неудачу для этого существует метод *ifValid* если до эвызова этого метода поле уже является ошибочным то остальные проверки производится не будут.

###Проверка правильности данных производится вызовом метода *isValid* главного объекта, который возвращает результат проверки данных ввиде булевого значения:

```php
<?php
#------
var_dump($verifier->isValid());
```

###В случае ошибочности данных, список ошибок можно получить при помощи метода *getErrors*, который вернет ассоциативный массив, ключами которого будут метки полей, а значеними список сообщений

```php
<?php
#------
var_dump($verifier->getErrors());
```
###В тех случаях когда поля данных зависят от друг друга можно установить Верификатору использование зависимости. В этом случаям методам проверки можно вместо значений, передавать путь к зависимому полю и значение будет использовано из этого зависимого поля:

```php
<?php
#------
$verifier->useDependency();
$verifier->field('password')->equal('password_confirm', 'Passwords must match');
```
###Пример проверки данных формы ввода состоящего из полей email, login, и списка url адресов:

```php
<?php
require_once 'Path_to_lib/Verifier.php';

$verifier = new Verifier\Verifier($_REQUEST['some_form']);

$verifier->field('email')
    ->notNull('`Email` field must not be empty')
    ->ifValid()->email('`Email` field is invalid format');

$verifier->field('login')
    ->notNull('`Login` field must not be empty');
    ->ifValid()->lengthMoreOrEqual(6, '`Login` field must be greater than 6 characters in length')
    ->byRegularExpression('/$\w/', '`Login` field must be begin with the words');

$verifier->each('urls')
    ->url('`Ulrs` fields has invalid format');

if ($verifier->isValid()) {
    // proccess data
} else {
    var_dump($verifier->getErrors());
}
```

Методы проверок полей.
----------------------
###Проверка на непустоту (*notEmpty*)

`notEmpty(string $message)`, где

* *$message* - выводимое сообщение в случае ошибки

###Проверка на эквивалентность

`equal(scalar $value, string $message)`, где

* *$value* - значение, которому должно быть эквивалентно значение поля
* *$message* - выводимое сообщение в случае ошибки

###Проверка на больше, меньше, больше или равно, меньше или равно

`more(scalar $value, string $message)`, `less(scalar $value, string $message)`, `moreOrEqual(scalar $value, string $message)` , `lessOrEqual(scalar $value, string $message)`, где

* *$value* - значение, для проверки
* *$message* - выводимое сообщение в случае ошибки

###Проверка на попадание начения в диапазон

`range(array $range, string $message)`, где

* *$range* - массив(список) из двух элементов задающий границы диапазона
* *$message* - выводимое сообщение в случае ошибки

###Проверка на попадание значения в список предложенных

`in(array $list, string $message)`, где

* *$list* - список допустимых значений
* *$message* - выводимое сообщение в случае ошибки

###Проверка на непопадание значения в список предложенных

`notIn(array $list, string $message)`, где

* *$list* - список недопустимых значений
* *$message* - выводимое сообщение в случае ошибки

###Проверка длины строки больше или равно, меньше или равно

`lengthMoreOrEqual(integer $lenght, string $message)`, `lengthLessOrEqual(integer $lenght, string $message)`, где

* *$length* - длина строки
* *$message* - выводимое сообщение в случае ошибки

###Проверка на соответствие формата чисовому значению

`numeric(string $message)`, где

* *$message* - выводимое сообщение в случае ошибки

###Проверка по *callback* функции

`byFunction(callback $function, string $message)`, где

* *$function* - функция принимающая на вход параметр соответствующий значению поля
* *$message* - выводимое сообщение в случае ошибки

###Проверка по регулярному выражению

`byRegularExpression(string $pattern, string $message)`, где

* *$pattern* - регулярное выражение для тестирования значения
* *$message* - выводимое сообщение в случае ошибки

###Проверка на соответствие формату электронного адреса

`email(string $message)`, где

* *$message* - выводимое сообщение в случае ошибки

###Проверка на соответствие формату url адреса

`url(string $message)`, где

* *$message* - выводимое сообщение в случае ошибки